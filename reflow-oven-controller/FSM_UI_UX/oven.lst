                 -1   $MODLP51RC2
0000              1   ;--------------------------------------------------------
0000              2   ; Register and bit definitions for the AT89LP51RC2/RB2
0000              3   ;--------------------------------------------------------
0000              4   ; Special Function Registers
0000              5   ;--------------------------------------------------------
0000              6   ACC            DATA 0xe0
0000              7   B              DATA 0xf0
0000              8   PSW            DATA 0xd0
0000              9   SP             DATA 0x81
0000             10   SPX            DATA 0xef
0000             11   DPL            DATA 0x82
0000             12   DPH            DATA 0x83
0000             13   DPLB           DATA 0xd4
0000             14   DPHB           DATA 0xd5
0000             15   PAGE           DATA 0xf6
0000             16   AX             DATA 0xe1
0000             17   BX             DATA 0xf7
0000             18   DSPR           DATA 0xe2
0000             19   FIRD           DATA 0xe3
0000             20   MACL           DATA 0xe4
0000             21   MACH           DATA 0xe5
0000             22   PCON           DATA 0x87
0000             23   AUXR           DATA 0x8e
0000             24   AUXR1          DATA 0xa2
0000             25   DPCF           DATA 0xa1
0000             26   CKRL           DATA 0x97
0000             27   CKCKON0        DATA 0x8f
0000             28   CKCKON1        DATA 0xaf
0000             29   CKSEL          DATA 0x85
0000             30   CLKREG         DATA 0xae
0000             31   OSCCON         DATA 0x86
0000             32   IE             DATA 0xa8
0000             33   IEN0           DATA 0xa8
0000             34   IEN1           DATA 0xb1
0000             35   IPH0           DATA 0xb7
0000             36   IP             DATA 0xb8
0000             37   IPL0           DATA 0xb8
0000             38   IPH1           DATA 0xb3
0000             39   IPL1           DATA 0xb2
0000             40   P0             DATA 0x80
0000             41   P1             DATA 0x90
0000             42   P2             DATA 0xa0
0000             43   P3             DATA 0xb0
0000             44   P4             DATA 0xc0
0000             45   P0M0           DATA 0xe6
0000             46   P0M1           DATA 0xe7
0000             47   P1M0           DATA 0xd6
0000             48   P1M1           DATA 0xd7
0000             49   P2M0           DATA 0xce
0000             50   P2M1           DATA 0xcf
0000             51   P3M0           DATA 0xc6
0000             52   P3M1           DATA 0xc7
0000             53   P4M0           DATA 0xbe
0000             54   P4M1           DATA 0xbf
0000             55   SCON           DATA 0x98
0000             56   SBUF           DATA 0x99
0000             57   SADEN          DATA 0xb9
0000             58   SADDR          DATA 0xa9
0000             59   BDRCON         DATA 0x9b
0000             60   BRL            DATA 0x9a
0000             61   TCON           DATA 0x88
0000             62   TMOD           DATA 0x89
0000             63   TCONB          DATA 0x91
0000             64   TL0            DATA 0x8a
0000             65   TH0            DATA 0x8c
0000             66   TL1            DATA 0x8b
0000             67   TH1            DATA 0x8d
0000             68   RL0            DATA 0xf2
0000             69   RL1            DATA 0xf3
0000             70   RH0            DATA 0xf4
0000             71   RH1            DATA 0xf5
0000             72   WDTRST         DATA 0xa6
0000             73   WDTPRG         DATA 0xa7
0000             74   T2CON          DATA 0xc8
0000             75   T2MOD          DATA 0xc9
0000             76   RCAP2H         DATA 0xcb
0000             77   RCAP2L         DATA 0xca
0000             78   TH2            DATA 0xcd
0000             79   TL2            DATA 0xcc
0000             80   SPCON          DATA 0xc3
0000             81   SPSTA          DATA 0xc4
0000             82   SPDAT          DATA 0xc5
0000             83   SSCON          DATA 0x93
0000             84   SSCS           DATA 0x94
0000             85   SSDAT          DATA 0x95
0000             86   SSADR          DATA 0x96
0000             87   KBLS           DATA 0x9c
0000             88   KBE            DATA 0x9d
0000             89   KBF            DATA 0x9e
0000             90   KBMOD          DATA 0x9f
0000             91   BMSEL          DATA 0x92
0000             92   FCON           DATA 0xd1
0000             93   EECON          DATA 0xd2
0000             94   ACSRA          DATA 0xa3
0000             95   ACSRB          DATA 0xab
0000             96   AREF           DATA 0xbd
0000             97   DADC           DATA 0xa4
0000             98   DADI           DATA 0xa5
0000             99   DADL           DATA 0xac
0000            100   DADH           DATA 0xad
0000            101   CCON           DATA 0xd8
0000            102   CMOD           DATA 0xd9
0000            103   CL             DATA 0xe9
0000            104   CH             DATA 0xf9
0000            105   CCAPM0         DATA 0xda
0000            106   CCAPM1         DATA 0xdb
0000            107   CCAPM2         DATA 0xdc
0000            108   CCAPM3         DATA 0xdd
0000            109   CCAPM4         DATA 0xde
0000            110   CCAP0H         DATA 0xfa
0000            111   CCAP1H         DATA 0xfb
0000            112   CCAP2H         DATA 0xfc
0000            113   CCAP3H         DATA 0xfd
0000            114   CCAP4H         DATA 0xfe
0000            115   CCAP0L         DATA 0xea
0000            116   CCAP1L         DATA 0xeb
0000            117   CCAP2L         DATA 0xec
0000            118   CCAP3L         DATA 0xed
0000            119   CCAP4L         DATA 0xee
0000            120   ;--------------------------------------------------------
0000            121   ; special function bits
0000            122   ;--------------------------------------------------------
0000            123   P              BIT 0xd0
0000            124   F1             BIT 0xd1
0000            125   OV             BIT 0xd2
0000            126   RS0            BIT 0xd3
0000            127   RS1            BIT 0xd4
0000            128   F0             BIT 0xd5
0000            129   AC             BIT 0xd6
0000            130   CY             BIT 0xd7
0000            131   EX0            BIT 0xa8
0000            132   ET0            BIT 0xa9
0000            133   EX1            BIT 0xaa
0000            134   ET1            BIT 0xab
0000            135   ES             BIT 0xac
0000            136   ET2            BIT 0xad
0000            137   EC             BIT 0xae
0000            138   EA             BIT 0xaf
0000            139   PX0            BIT 0xb8
0000            140   PT0            BIT 0xb9
0000            141   PX1            BIT 0xba
0000            142   PT1            BIT 0xbb
0000            143   PS             BIT 0xbc
0000            144   PT2            BIT 0xbd
0000            145   IP0D           BIT 0xbf
0000            146   PPCL           BIT 0xbe
0000            147   PT2L           BIT 0xbd
0000            148   PLS            BIT 0xbc
0000            149   PT1L           BIT 0xbb
0000            150   PX1L           BIT 0xba
0000            151   PT0L           BIT 0xb9
0000            152   PX0L           BIT 0xb8
0000            153   RXD            BIT 0xb0
0000            154   TXD            BIT 0xb1
0000            155   INT0           BIT 0xb2
0000            156   INT1           BIT 0xb3
0000            157   T0             BIT 0xb4
0000            158   T1             BIT 0xb5
0000            159   WR             BIT 0xb6
0000            160   RD             BIT 0xb7
0000            161   RI             BIT 0x98
0000            162   TI             BIT 0x99
0000            163   RB8            BIT 0x9a
0000            164   TB8            BIT 0x9b
0000            165   REN            BIT 0x9c
0000            166   SM2            BIT 0x9d
0000            167   SM1            BIT 0x9e
0000            168   SM0            BIT 0x9f
0000            169   IT0            BIT 0x88
0000            170   IE0            BIT 0x89
0000            171   IT1            BIT 0x8a
0000            172   IE1            BIT 0x8b
0000            173   TR0            BIT 0x8c
0000            174   TF0            BIT 0x8d
0000            175   TR1            BIT 0x8e
0000            176   TF1            BIT 0x8f
0000            177   CP_RL2         BIT 0xc8
0000            178   C_T2           BIT 0xc9
0000            179   TR2            BIT 0xca
0000            180   EXEN2          BIT 0xcb
0000            181   TCLK           BIT 0xcc
0000            182   RCLK           BIT 0xcd
0000            183   EXF2           BIT 0xce
0000            184   TF2            BIT 0xcf
0000            185   CF             BIT 0xdf
0000            186   CR             BIT 0xde
0000            187   CCF4           BIT 0xdc
0000            188   CCF3           BIT 0xdb
0000            189   CCF2           BIT 0xda
0000            190   CCF1           BIT 0xd9
0000            191   CCF0           BIT 0xd8
0000              2   org 0000H
0000 02050C       3      ljmp MainProgram
0003              4   
0003              5   ; Timer/Counter 0 overflow interrupt vector
000B              6   org 0x000B
000B 0203EE       7            ljmp Timer0_ISR
000E              8   
001B              9   org 0x001B ; Timer/Counter 1 overflow interrupt vector. Used in this code to replay the wave file.
001B 0203FB      10            ljmp Timer1_ISR
001E             11   
001E             12   ; Timer/Counter 2 overflow interrupt vector
002B             13   org 0x002B
002B 02044D      14            ljmp Timer2_ISR
002E             15   
002E             16   CLK                              EQU 22118400
002E             17   BAUD                             EQU 115200
002E             18   BRG_VAL                          EQU (0x100-(CLK/(16*BAUD)))
002E             19   TIMER0_RATE              EQU 1000    ; 1000Hz PWM output signal 
002E             20   TIMER0_RELOAD            EQU ((65536-(CLK/TIMER0_RATE)))
002E             21   TIMER1_RATE              EQU 22050   ; 22050Hz is the sampling rate of the wav file we are playing
002E             22   TIMER1_RELOAD            EQU 0x10000-(SYSCLK/TIMER1_RATE)
002E             23   TIMER2_RATE              EQU 1000    ; 1000Hz, for a timer tick of 1ms
002E             24   TIMER2_RELOAD            EQU ((65536-(CLK/TIMER2_RATE)))
002E             25   
002E             26   HOLD_PWM                         EQU 20          ; 20% pwm for holding the temp constant 
002E             27   PWM_HOLD_RATE            EQU (TIMER0_RATE-(HOLD_PWM*10))
002E             28   
002E             29   ; Commands supported by the SPI flash memory according to the datasheet
002E             30   WRITE_ENABLE     EQU 0x06  ; Address:0 Dummy:0 Num:0
002E             31   WRITE_DISABLE    EQU 0x04  ; Address:0 Dummy:0 Num:0
002E             32   READ_STATUS      EQU 0x05  ; Address:0 Dummy:0 Num:1 to infinite
002E             33   READ_BYTES       EQU 0x03  ; Address:3 Dummy:0 Num:1 to infinite
002E             34   READ_SILICON_ID  EQU 0xab  ; Address:0 Dummy:3 Num:1 to infinite
002E             35   FAST_READ        EQU 0x0b  ; Address:3 Dummy:1 Num:1 to infinite
002E             36   WRITE_STATUS     EQU 0x01  ; Address:0 Dummy:0 Num:1
002E             37   WRITE_BYTES      EQU 0x02  ; Address:3 Dummy:0 Num:1 to 256
002E             38   ERASE_ALL        EQU 0xc7  ; Address:0 Dummy:0 Num:0
002E             39   ERASE_BLOCK      EQU 0xd8  ; Address:3 Dummy:0 Num:0
002E             40   READ_DEVICE_ID   EQU 0x9f  ; Address:0 Dummy:2 Num:1 to infinite
002E             41   
002E             42   ;----------------------------------Ports!----------------------------------------
002E             43   SPEAKER                  EQU P2.4                ; Used with a MOSFET to turn off speaker when not in use
002E             44   OUTPUT                   EQU P0.2                ; output signal to the relay box
002E             45   
002E             46   ; These 'equ' must match the hardware wiring
002E             47   ; They are used by 'LCD_4bit.inc'
002E             48   LCD_RS                   EQU P3.2
002E             49   ; LCD_RW equ Px.x ; Always grounded
002E             50   LCD_E                    EQU P3.3
002E             51   LCD_D4                   EQU P3.4
002E             52   LCD_D5                   EQU P3.5
002E             53   LCD_D6                   EQU P3.6
002E             54   LCD_D7                   EQU P3.7
002E             55   ; These ’EQU’ must match the wiring between the microcontroller and ADC 
002E             56   CE_ADC                   EQU P2.0 
002E             57   MY_MOSI_ADC          EQU P2.1 
002E             58   MY_MISO_ADC      EQU P2.2 
002E             59   MY_SCLK_ADC      EQU P1.7 
002E             60   
002E             61   ; Pins used for SPI for flash memory 
002E             62   FLASH_CE                 EQU P0.7                ; Pin 1
002E             63   MY_MOSI                  EQU P2.5                ; Pin 5
002E             64   MY_MISO                  EQU P2.7                ; Pin 2
002E             65   MY_SCLK                  EQU P0.4                ; Pin 6
002E             66   
002E             67   ; UI buttons pin
002E             68   DECR            EQU P0.0                 ; button to increment current selection
002E             69   INCR            EQU P0.3                 ; button to increment current selection
002E             70   EDIT                     EQU P0.6                ; button for changing what to edit
002E             71   START_STOP               EQU P4.5                ; button to start/stop reflow
002E             72   RST                              EQU     P2.6            ; button to reset
002E             73   ; i have buttons on 2.6, 4.5, 0.6, 0.3, 0.0 (left to right)
002E             74   ;--------------------------------------------------------------------------------
002E             75   
002E             76   ; These register definitions needed by 'math32.inc'
0030             77   DSEG at 30H
0030             78   x:                               ds 4
0034             79   y:                               ds 4
0038             80   bcd:                             ds 5
003D             81   Result:                          ds 2
003F             82   w:                               ds 3 ; 24-bit play counter.  Decremented in Timer 1 ISR.
0042             83   
0042             84   ;--------------------for clock----------------------
0042             85   Count1ms:                ds 2 ; Used to determine when one second has passed
0044             86   secs_ctr:                ds 1
0045             87   mins_ctr:                ds 1
0046             88   pwm_time:                        ds 1 ; Used to check whether it is time to turn on the pwm output
0047             89   ;---------------------------------------------------
0047             90   
0047             91   ;--------------------for settings-------------------
0047             92   edit_sett:               ds 1 ; which segment are we editing 
0048             93   ; 0 - soak temp
0048             94   ; 1 - soak time
0048             95   ; 2 - reflow temp
0048             96   ; 3 - reflow time
0048             97   ; 4 - cool temp
0048             98   
0048             99   ;---------------------------------------------------
0048            100   
0048            101   ;--------------------for FSM------------------------
0048            102   state:                           ds 1                            
0049            103   soak_temp:                       ds 1
004A            104   soak_time:                       ds 1
004B            105   reflow_temp:             ds 1
004C            106   reflow_time:             ds 1
004D            107   cool_temp:                       ds 1
004E            108   pwm:                             ds 1
004F            109   sec:                             ds 1
0050            110   temp:                            ds 1
0051            111   ;---------------------------------------------------
0051            112   
0000            113   BSEG
0000            114   mf:                              dbit 1 ; flag for math32
0001            115   start_flag:              dbit 1
0002            116   one_second_flag:         dbit 1 ; Set to one in the ISR every time 1000 ms had passed
0003            117   safety_overheat:    dbit 1 ; for overheat safety feature
0004            118   
002E            119   CSEG
                546   $LIST
                123   	$LIST
0360            125   
0360            126   ;------------------UI-UX vars---------------------
0360            127   ;            1234567890123456
0360 736F616B   128   setup1:  db 'soak            ', 0
     20202020
     20202020
     20202020
     00
0371 746D703A   129   setup2:  db 'tmp:XXX time:XXX', 0
     58585820
     74696D65
     3A585858
     00
0382 7265666C   130   setup3:  db 'refl            ', 0
     20202020
     20202020
     20202020
     00
0393 636F6F6C   131   setup4:  db 'cool *          ', 0
     202A2020
     20202020
     20202020
     00
03A4 746D703A   132   setup5:  db 'tmp:XXX         ', 0
     58585820
     20202020
     20202020
     00
03B5            133   
03B5 74656D70   134   run1:    db 'temp:XXX state X', 0
     3A585858
     20737461
     74652058
     00
03C6 656C6170   135   run2:    db 'elapsed XX:XX   ', 0
     73656420
     58583A58
     58202020
     00
03D7            136   
03D7            137   Timer0_Init:
03D7 E589       138            mov a, TMOD
03D9 54F0       139            anl a, #0xf0 ; 11110000 Clear the bits for timer 0
03DB 4401       140            orl a, #0x01 ; 00000001 Configure timer 0 as 16-timer
03DD F589       141            mov TMOD, a
03DF 758CA9     142            mov TH0, #high(TIMER0_RELOAD)
03E2 758A9A     143            mov TL0, #low(TIMER0_RELOAD)
03E5            144            ; Set autoreload value
03E5 75F4A9     145            mov RH0, #high(TIMER0_RELOAD)
03E8 75F29A     146            mov RL0, #low(TIMER0_RELOAD)
03EB            147            ; Enable the timer and interrupts
03EB D2A9       148       setb ET0  ; Enable timer 0 interrupt
03ED            149       ; setb TR0  ; Start timer 0
03ED 22         150            ret
03EE            151   
03EE            152   ;---------------------------------;
03EE            153   ; ISR for timer 0.  Set to execute;
03EE            154   ; every 1/4096Hz to generate a    ;
03EE            155   ; 2048 Hz square wave at pin P1.1 ;
03EE            156   ;---------------------------------;
03EE            157   Timer0_ISR:
03EE            158            ;clr TF0  ; According to the data sheet this is done for us already.
03EE 758CA9     159            mov TH0, #high(TIMER0_RELOAD)
03F1 758A9A     160            mov TL0, #low(TIMER0_RELOAD)
03F4            161            ; Set autoreload value
03F4 75F4A9     162            mov RH0, #high(TIMER0_RELOAD)
03F7 75F29A     163            mov RL0, #low(TIMER0_RELOAD)
03FA 32         164            reti
03FB            165   
03FB            166   ;-------------------------------------;
03FB            167   ; ISR for Timer 1.  Used to playback  ;
03FB            168   ; the WAV file stored in the SPI      ;
03FB            169   ; flash memory.                       ;
03FB            170   ;-------------------------------------;
03FB            171   Timer1_ISR:
03FB            172       ; The registers used in the ISR must be saved in the stack
03FB C0E0       173       push acc
03FD C0D0       174       push psw
03FF            175   
03FF            176       ; Check if the play counter is zero.  If so, stop playing sound.
03FF E53F       177       mov a, w+0
0401 4540       178       orl a, w+1
0403 4541       179       orl a, w+2
0405 601C       180       jz stop_playing
0407            181   
0407            182       ; Decrement play counter 'w'.  In this implementation 'w' is a 24-bit counter.
0407 74FF       183       mov a, #0xff
0409 153F       184       dec w+0
040B B53F07     185       cjne a, w+0, keep_playing
040E 1540       186       dec w+1
0410 B54002     187       cjne a, w+1, keep_playing
0413 1541       188       dec w+2
0415            189   
0415            190   keep_playing:
0415 D2A4       191       setb SPEAKER
0417 1204B3     192       lcall Send_SPI ; Read the next byte from the SPI Flash...
041A 2480       193       add a, #0x80
041C F5AD       194       mov DADH, a ; Output to DAC. DAC output is pin P2.3
041E 43A440     195       orl DADC, #0b_0100_0000 ; Start DAC by setting GO/BSY=1
0421 800C       196       sjmp Timer1_ISR_Done
0423            197   
0423            198   stop_playing:
0423 C28E       199       clr TR1 ; Stop timer 1
0425 D287       200       setb FLASH_CE ; Disable SPI Flash
0427 C2A4       201       clr SPEAKER ; Turn off speaker.  Removes hissing noise when not playing sound.
0429 75AD80     202       mov DADH, #0x80 ; middle of range
042C 43A440     203      orl DADC, #0b_0100_0000 ; Start DAC by setting GO/BSY=1
042F            204   
042F            205   Timer1_ISR_Done:
042F D0D0       206       pop psw
0431 D0E0       207       pop acc
0433 32         208       reti
0434            209   
0434            210   ;---------------------------------;
0434            211   ; Routine to initialize the ISR   ;
0434            212   ; for timer 2                     ;
0434            213   ;---------------------------------;
0434            214   Timer2_Init:
0434 75C800     215            mov T2CON, #0 ; Stop timer/counter.  Autoreload mode.
0437 75CDA9     216            mov TH2, #high(TIMER2_RELOAD)
043A 75CC9A     217            mov TL2, #low(TIMER2_RELOAD)
043D            218            ; Set the reload value
043D 75CBA9     219            mov RCAP2H, #high(TIMER2_RELOAD)
0440 75CA9A     220            mov RCAP2L, #low(TIMER2_RELOAD)
0443            221            ; Init One millisecond interrupt counter.  It is a 16-bit variable made with two 8-bit parts
0443 E4         222            clr a
0444 F542       223            mov Count1ms+0, a
0446 F543       224            mov Count1ms+1, a
0448            225            ; Enable the timer and interrupts
0448 D2AD       226       setb ET2  ; Enable timer 2 interrupt
044A D2CA       227       setb TR2  ; Enable timer 2
044C 22         228            ret
044D            229   
044D            230   ;---------------------------------;
044D            231   ; ISR for timer 2                 ;
044D            232   ;---------------------------------;
044D            233   Timer2_ISR:
044D C2CF       234            clr TF2  ; Timer 2 doesn't clear TF2 automatically. Do it in ISR
044F            235            ;cpl P1.0 ; To check the interrupt rate with oscilloscope. It must be precisely a 1 ms pulse.
044F            236            
044F            237            ; The two registers used in the ISR must be saved in the stack
044F C0E0       238            push acc
0451 C0D0       239            push psw
0453            240            
0453            241            ; Increment the 16-bit one mili second counter
0453 0542       242            inc Count1ms+0    ; Increment the low 8-bits first
0455 E542       243            mov a, Count1ms+0 ; If the low 8-bits overflow, then increment high 8-bits
0457 7002       244            jnz Inc_Done
0459 0543       245            inc Count1ms+1
045B            246   
045B            247   Inc_Done:
045B            248            ; Check if second has passed
045B E542       249            mov a, Count1ms+0
045D B4E831     250            cjne a, #low(1000), Timer2_ISR_done ; Warning: this instruction changes the carry flag!
0460 E543       251            mov a, Count1ms+1
0462 B4032C     252            cjne a, #high(1000), Timer2_ISR_done
0465            253            
0465            254            ; 1000 milliseconds have passed.  Set a flag so the main program knows
0465 D202       255            setb one_second_flag ; Let the main program know second had passed
0467            256                    
0467            257            ; Reset to zero the milli-seconds counter, it is a 16-bit variable
0467 E4         258            clr a
0468 F542       259            mov Count1ms+0, a
046A F543       260            mov Count1ms+1, a
046C            261            
046C            262            ; reset secs_ctr if hits 60, increment 1 to minutes
046C            263            ; Increment the seconds counter
046C E544       264            mov a, secs_ctr
046E B45910     265            cjne a, #0x59, Timer2_ISR_increment_s
0471 E4         266            clr a
0472 D4         267            da a ; Decimal adjust instruction.  Check datasheet for more details!
0473 F544       268            mov secs_ctr, a
0475            269            
0475            270            ; increment the minutes counter
0475 E545       271            mov a, mins_ctr
0477 B4590F     272            cjne a, #0x59, Timer2_ISR_increment_m
047A E4         273            clr a
047B D4         274            da a
047C F545       275            mov mins_ctr, a
047E            276   
047E 020491     277            ljmp Timer2_ISR_done
0481            278            
0481            279   Timer2_ISR_increment_s:
0481 2401       280            add a, #0x01
0483 D4         281            da a ; Decimal adjust instruction.  Check datasheet for more details!
0484 F544       282            mov secs_ctr, a
0486 020491     283            ljmp Timer2_ISR_done
0489            284   Timer2_ISR_increment_m:
0489 2401       285            add a, #0x01
048B D4         286            da a ; Decimal adjust instruction.  Check datasheet for more details!
048C F545       287            mov mins_ctr, a
048E 020491     288            ljmp Timer2_ISR_done
0491            289   Timer2_ISR_done:
0491 D0D0       290            pop psw
0493 D0E0       291            pop acc
0495 32         292            reti
0496            293   
0496            294   ; Configure the serial port and baud rate
0496            295   InitSerialPort:
0496            296       ; Since the reset button bounces, we need to wait a bit before
0496            297       ; sending messages, otherwise we risk displaying gibberish!
0496 79DE       298            mov R1, #222
0498 78A6       299       mov R0, #166
049A D8FE       300       djnz R0, $   ; 3 cycles->3*45.21123ns*166=22.51519us
049C D9FA       301       djnz R1, $-4 ; 22.51519us*222=4.998ms
049E            302       ; Now we can proceed with the configuration
049E 438780     303            orl     PCON,#0x80
04A1 759852     304            mov     SCON,#0x52
04A4 759B00     305            mov     BDRCON,#0x00
04A7 759AF4     306            mov     BRL,#BRG_VAL
04AA 759B1E     307            mov     BDRCON,#0x1E ; BDRCON=BRR|TBCK|RBCK|SPD;
04AD 22         308       ret
04AE            309       
04AE            310   INIT_SPI: 
04AE D2A2       311            setb MY_MISO_ADC ; Make MISO an input pin
04B0 C297       312            clr MY_SCLK_ADC ; For mode (0,0) SCLK is zero
04B2 22         313            ret
04B3            314   
04B3            315   ;---------------------------------;
04B3            316   ; Sends AND receives a byte via   ;
04B3            317   ; SPI.                            ;
04B3            318   ;---------------------------------;
04B3            319   Send_SPI:
04B3            320                ; Send/Receive bit 7
04B3 33         320                    rlc a
04B4 92A5       320                    mov MY_MOSI, c
04B6 D284       320                    setb MY_SCLK
04B8 A2A7       320                    mov c, MY_MISO
04BA C284       320                    clr MY_SCLK
04BC 92E0       320                    mov acc.0, c
04BE            321                ; Send/Receive bit 6
04BE 33         321                    rlc a
04BF 92A5       321                    mov MY_MOSI, c
04C1 D284       321                    setb MY_SCLK
04C3 A2A7       321                    mov c, MY_MISO
04C5 C284       321                    clr MY_SCLK
04C7 92E0       321                    mov acc.0, c
04C9            322                ; Send/Receive bit 5
04C9 33         322                    rlc a
04CA 92A5       322                    mov MY_MOSI, c
04CC D284       322                    setb MY_SCLK
04CE A2A7       322                    mov c, MY_MISO
04D0 C284       322                    clr MY_SCLK
04D2 92E0       322                    mov acc.0, c
04D4            323                ; Send/Receive bit 4
04D4 33         323                    rlc a
04D5 92A5       323                    mov MY_MOSI, c
04D7 D284       323                    setb MY_SCLK
04D9 A2A7       323                    mov c, MY_MISO
04DB C284       323                    clr MY_SCLK
04DD 92E0       323                    mov acc.0, c
04DF            324                ; Send/Receive bit 3
04DF 33         324                    rlc a
04E0 92A5       324                    mov MY_MOSI, c
04E2 D284       324                    setb MY_SCLK
04E4 A2A7       324                    mov c, MY_MISO
04E6 C284       324                    clr MY_SCLK
04E8 92E0       324                    mov acc.0, c
04EA            325                ; Send/Receive bit 2
04EA 33         325                    rlc a
04EB 92A5       325                    mov MY_MOSI, c
04ED D284       325                    setb MY_SCLK
04EF A2A7       325                    mov c, MY_MISO
04F1 C284       325                    clr MY_SCLK
04F3 92E0       325                    mov acc.0, c
04F5            326                ; Send/Receive bit 1
04F5 33         326                    rlc a
04F6 92A5       326                    mov MY_MOSI, c
04F8 D284       326                    setb MY_SCLK
04FA A2A7       326                    mov c, MY_MISO
04FC C284       326                    clr MY_SCLK
04FE 92E0       326                    mov acc.0, c
0500            327                ; Send/Receive bit 0
0500 33         327                    rlc a
0501 92A5       327                    mov MY_MOSI, c
0503 D284       327                    setb MY_SCLK
0505 A2A7       327                    mov c, MY_MISO
0507 C284       327                    clr MY_SCLK
0509 92E0       327                    mov acc.0, c
050B            328   
050B 22         329            ret
050C            330   ; -------------------------------------------------- MAIN PROGRAM LOOP ----------------------------------------------
050C            331   
050C            332   MainProgram: ; setup()
050C 75817F     333       mov SP, #7FH                                                 ; Set the stack pointer to the begining of idata
050F            334       
050F C282       335            clr OUTPUT                                                      ; pwm is set to low by default
0511 1209AC     336            lcall Load_Configuration ; initialize settings
0514 120496     337       lcall InitSerialPort
0517 1204AE     338       lcall INIT_SPI
051A 12030E     339       lcall LCD_4BIT
051D            340   
051D            341       ;initialize flags
051D C201       342       clr start_flag
051F 750300     343       mov safety_overheat, #0
0522            344   
0522            345       ;initialize fsm
0522 754800     346       mov state, #0
0525            347   
0525            348       ;init clock
0525 754400     349       mov secs_ctr, #0
0528 754500     350       mov mins_ctr, #0
052B C202       351       clr one_second_flag
052D            352   
052D            353       ;init settings
052D 754700     354       mov edit_sett, #0
0530            355       
0530 1203D7     356       lcall Timer0_Init
0533            357       ;lcall Timer1_Init                   ;uncomment for speaker config
0533 120434     358       lcall Timer2_Init
0536            359   
0536 D2AF       360       setb EA                                                      ; Enable Global interrupts
0538            361   
0538            362   forever: ;loop() please only place function calls into the loop!
0538 300205     363       jnb one_second_flag, skipDisplay     ; this segment only executes once a second
053B C202       364       clr one_second_flag
053D            365       
053D            366       ;lcall readADC                                               ; reads ch0 and saves result to Result as 2 byte binary
053D            367       ;lcall Do_Something_With_Result ; convert to bcd and send to serial
053D            368       ;lcall checkOverheat
053D 120607     369       lcall generateDisplay
0540            370       
0540            371       skipDisplay:                                                 ; end segment
0540            372   
0540 200106     373       jb start_flag, skipPoll
0543 1207FD     374       lcall pollButtons                                    ; poll buttons for editing screen
0546 020538     375       ljmp forever
0549            376       skipPoll: 
0549            377   
0549            378       ;lcall reset                                                 ; check if reset is pressed
0549            379       ;ljmp FSM                                                    ; finite state machine logic
0549 020538     380            ljmp forever
054C            381   
054C            382   ; ---------------------------------------------------------------------------------------------------
054C            383   
054C            384   ;----------------------------------safety-features---------------------------------------------------
054C            385   checkOverheat:
054C E550       386       mov a, temp
054E C3         387            clr c
054F 94FB       388            subb a, #251                            ; if 251 > temp, c = 1
0551 4006       389            jc notOverheat                          ; return if notOverheating
0553 200306     390       jb safety_overheat, overheatReset ; check if flag is set, if set that means has been overheating for prolonged time
0556 D203       391            setb safety_overheat        ; set overheat flag for next time
0558 22         392       ret
0559            393   notOverheat:
0559 C203       394       clr safety_overheat
055B 22         395            ret
055C            396   overheatReset:
055C C203       397       clr safety_overheat
055E 7405       398       mov a, #5                                            ; reset to state 5 when reset for safety
0560 22         399       ret
0561            400   ;----------------------------------------------------------------------------------------------------
0561            401   readADC:
0561 C2A0       402       clr CE_ADC
0563 7801       403            mov R0, #00000001B ; Start bit:1
0565 1205C8     404            lcall DO_SPI_G
0568 7880       405            mov R0, #10000000B ; Single ended, read channel 0
056A 1205C8     406            lcall DO_SPI_G
056D E9         407            mov a, R1 ; R1 contains bits 8 and 9
056E 5403       408            anl a, #00000011B ; We need only the two least significant bits
0570 F53E       409            mov Result+1, a ; Save result high.
0572 7855       410            mov R0, #55H ; It doesn't matter what we transmit...
0574 1205C8     411            lcall DO_SPI_G
0577 893D       412            mov Result, R1 ; R1 contains bits 0 to 7. Save result low.
0579 D2A0       413            setb CE_ADC
057B 22         414       ret
057C            415   
057C            416   Do_Something_With_Result:
057C 853D30     417            mov x+0, result+0
057F 853E31     418            mov x+1, result+1
0582 753200     419            mov x+2, #0
0585 753300     420            mov x+3, #0
0588            421            
0588 75349A     422            mov y+0, #low (410 % 0x10000) 
058B 753501     422            mov y+1, #high(410 % 0x10000) 
058E 753600     422            mov y+2, #low (410 / 0x10000) 
0591 753700     422            mov y+3, #high(410 / 0x10000) 
0594 1201A8     423            lcall mul32
0597            424            
0597 7534FF     425            mov y+0, #low (1023 % 0x10000) 
059A 753503     425            mov y+1, #high(1023 % 0x10000) 
059D 753600     425            mov y+2, #low (1023 / 0x10000) 
05A0 753700     425            mov y+3, #high(1023 / 0x10000) 
05A3 120235     426            lcall div32
05A6            427            
05A6 753411     428            mov y+0, #low (273 % 0x10000) 
05A9 753501     428            mov y+1, #high(273 % 0x10000) 
05AC 753600     428            mov y+2, #low (273 / 0x10000) 
05AF 753700     428            mov y+3, #high(273 / 0x10000) 
05B2 120114     429            lcall sub32
05B5            430            
05B5 12002E     431            lcall hex2bcd
05B8 1205E1     432            lcall Send_3_digit_BCD
05BB            433            
05BB E530       434            mov a, x
05BD B43200     435            cjne a, #50, NOT_EQ
05C0 4003       436            NOT_EQ: JC REQ_LOW
05C2 D28C       437            setb TR0
05C4 22         438            ret
05C5            439            REQ_LOW:
05C5 C28C       440            clr TR0
05C7 22         441            ret
05C8            442   
05C8            443   DO_SPI_G: 
05C8 C0E0       444            push acc 
05CA 7900       445            mov R1, #0 ; Received byte stored in R1
05CC 7A08       446            mov R2, #8 ; Loop counter (8-bits)
05CE            447   DO_SPI_G_LOOP: 
05CE E8         448            mov a, R0 ; Byte to write is in R0
05CF 33         449            rlc a ; Carry flag has bit to write
05D0 F8         450            mov R0, a 
05D1 92A1       451            mov MY_MOSI_ADC, c 
05D3 D297       452            setb MY_SCLK_ADC ; Transmit
05D5 A2A2       453            mov c, MY_MISO_ADC ; Read received bit
05D7 E9         454            mov a, R1 ; Save received bit in R1
05D8 33         455            rlc a 
05D9 F9         456            mov R1, a 
05DA C297       457            clr MY_SCLK_ADC 
05DC DAF0       458            djnz R2, DO_SPI_G_LOOP 
05DE D0E0       459            pop acc 
05E0 22         460            ret
05E1            461            
05E1            462   Send_3_Digit_BCD: ;send 3 digits bcd in BCD var to putty
05E1 E539       463       mov a, bcd+1
05E3 540F       464       anl a, #0fh
05E5 4430       465       orl a, #'0'
05E7 F8         466       mov r0, a
05E8 1205FF     467       lcall putchar
05EB C000       468            push ar0
05ED A838       468            mov r0, bcd+0
05EF 12029E     468            lcall ?Send_BCD
05F2 D000       468            pop ar0
05F4 740D       469            mov a, #'\r'
05F6 1205FF     470            lcall putchar
05F9 740A       471            mov a, #'\n'
05FB 1205FF     472            lcall putchar
05FE 22         473            ret
05FF            474   
05FF            475   ; Send a character using the serial port
05FF            476   putchar:
05FF 3099FD     477       jnb TI, putchar
0602 C299       478       clr TI
0604 F599       479       mov SBUF, a
0606 22         480       ret
0607            481   
0607            482   ;----------------------------------UI CODE----------------------------------------------
0607            483   generateDisplay:
0607 200103     484       jb start_flag, startDisplay
060A 0206A2     485       ljmp setupDisplay
060D            486   
060D            487   startDisplay:
060D C0E0       488            push acc
060F 7401       488            mov a, #1
0611 14         488            dec a
0612 120345     488            lcall ?Set_Cursor_1 ; Select column and row
0615 D0E0       488            pop acc
0617 C083       489            push dph
0619 C082       489            push dpl
061B C0E0       489            push acc
061D 9003B5     489            mov dptr, #run1
0620 120338     489            lcall ?Send_Constant_String
0623 D0E0       489            pop acc
0625 D082       489            pop dpl
0627 D083       489            pop dph
0629 C0E0       490            push acc
062B 7401       490            mov a, #1
062D 14         490            dec a
062E 120343     490            lcall ?Set_Cursor_2 ; Select column and row
0631 D0E0       490            pop acc
0633 C083       491            push dph
0635 C082       491            push dpl
0637 C0E0       491            push acc
0639 9003C6     491            mov dptr, #run2
063C 120338     491            lcall ?Send_Constant_String
063F D0E0       491            pop acc
0641 D082       491            pop dpl
0643 D083       491            pop dph
0645            492       
0645 C0E0       493            push acc
0647 7406       493            mov a, #6
0649 14         493            dec a
064A 120345     493            lcall ?Set_Cursor_1 ; Select column and row
064D D0E0       493            pop acc
064F E550       494       mov a, temp
0651 12087A     495       lcall SendToLCD
0654            496   
0654 C0E0       497            push acc
0656 7410       497            mov a, #16
0658 14         497            dec a
0659 120345     497            lcall ?Set_Cursor_1 ; Select column and row
065C D0E0       497            pop acc
065E 753000     498            mov x+0, #low (0 % 0x10000) 
0661 753100     498            mov x+1, #high(0 % 0x10000) 
0664 753200     498            mov x+2, #low (0 / 0x10000) 
0667 753300     498            mov x+3, #high(0 / 0x10000) 
066A 854830     499       mov x+0, state
066D 12002E     500       lcall hex2bcd
0670            501       ; Display digit 1
0670 E538       502       mov a, bcd+0
0672 540F       503       anl a, #0fh
0674 4430       504       orl a, #'0'
0676 F8         505       mov r0, a
0677 E8         506            mov a, r0
0678 120304     506            lcall ?WriteData
067B            507   
067B C0E0       508            push acc
067D 7409       508            mov a, #9
067F 14         508            dec a
0680 120343     508            lcall ?Set_Cursor_2 ; Select column and row
0683 D0E0       508            pop acc
0685 C000       509            push ar0
0687 A845       509            mov r0, mins_ctr
0689 12034A     509            lcall ?Display_BCD
068C D000       509            pop ar0
068E C0E0       510            push acc
0690 740C       510            mov a, #12
0692 14         510            dec a
0693 120343     510            lcall ?Set_Cursor_2 ; Select column and row
0696 D0E0       510            pop acc
0698 C000       511            push ar0
069A A844       511            mov r0, secs_ctr
069C 12034A     511            lcall ?Display_BCD
069F D000       511            pop ar0
06A1 22         512       ret
06A2            513   
06A2            514   ;             1234567890123456
06A2            515   ;setup1:  db 'soak            ', 0
06A2            516   ;setup2:  db 'tmp:XXX time:XXX', 0
06A2            517   ;setup3:  db 'reflow          ', 0
06A2            518   
06A2            519   ;run1:    db 'temp:XXX state X', 0
06A2            520   ;run2:    db 'elapsed XX:XX   ', 0
06A2            521   
06A2            522   setupDisplay:
06A2 E547       523       mov a, edit_sett
06A4 B40003     524       cjne a, #0, checkScreen1
06A7 0206BF     525       ljmp soakScreen
06AA            526   checkScreen1:
06AA B40103     527       cjne a, #1, checkScreen2
06AD 0206BF     528       ljmp soakScreen
06B0            529   checkScreen2:
06B0 B40203     530       cjne a, #2, checkScreen3
06B3 02073A     531       ljmp reflowScreen
06B6            532   checkScreen3:
06B6 B40303     533       cjne a, #3, checkScreen4
06B9 02073A     534       ljmp reflowScreen
06BC            535   checkScreen4:
06BC 0207B5     536       ljmp coolScreen
06BF            537   soakScreen:
06BF C0E0       538            push acc
06C1 7401       538            mov a, #1
06C3 14         538            dec a
06C4 120345     538            lcall ?Set_Cursor_1 ; Select column and row
06C7 D0E0       538            pop acc
06C9 C083       539            push dph
06CB C082       539            push dpl
06CD C0E0       539            push acc
06CF 900360     539            mov dptr, #setup1
06D2 120338     539            lcall ?Send_Constant_String
06D5 D0E0       539            pop acc
06D7 D082       539            pop dpl
06D9 D083       539            pop dph
06DB C0E0       540            push acc
06DD 7401       540            mov a, #1
06DF 14         540            dec a
06E0 120343     540            lcall ?Set_Cursor_2 ; Select column and row
06E3 D0E0       540            pop acc
06E5 C083       541            push dph
06E7 C082       541            push dpl
06E9 C0E0       541            push acc
06EB 900371     541            mov dptr, #setup2
06EE 120338     541            lcall ?Send_Constant_String
06F1 D0E0       541            pop acc
06F3 D082       541            pop dpl
06F5 D083       541            pop dph
06F7            542   
06F7            543   updateSoakScreen:
06F7 C0E0       544            push acc
06F9 7405       544            mov a, #5
06FB 14         544            dec a
06FC 120343     544            lcall ?Set_Cursor_2 ; Select column and row
06FF D0E0       544            pop acc
0701 E549       545       mov a, soak_temp
0703 12087A     546       lcall SendToLCD
0706            547   
0706 C0E0       548            push acc
0708 740E       548            mov a, #14
070A 14         548            dec a
070B 120343     548            lcall ?Set_Cursor_2 ; Select column and row
070E D0E0       548            pop acc
0710 E54A       549       mov a, soak_time
0712 12087A     550       lcall SendToLCD
0715            551   
0715 E547       552       mov a, edit_sett
0717 B4000C     553       cjne a, #0, indic_soak_time
071A C0E0       554            push acc
071C 7406       554            mov a, #6
071E 14         554            dec a
071F 120345     554            lcall ?Set_Cursor_1 ; Select column and row
0722 D0E0       554            pop acc
0724 800A       555       sjmp indic_soak_next
0726            556   indic_soak_time:
0726 C0E0       557            push acc
0728 740F       557            mov a, #15
072A 14         557            dec a
072B 120345     557            lcall ?Set_Cursor_1 ; Select column and row
072E D0E0       557            pop acc
0730            558   indic_soak_next:
0730 C0E0       559            push acc
0732 742A       559            mov a, #'*'
0734 120304     559            lcall ?WriteData
0737 D0E0       559            pop acc
0739 22         560       ret
073A            561   reflowScreen:
073A C0E0       562            push acc
073C 7401       562            mov a, #1
073E 14         562            dec a
073F 120345     562            lcall ?Set_Cursor_1 ; Select column and row
0742 D0E0       562            pop acc
0744 C083       563            push dph
0746 C082       563            push dpl
0748 C0E0       563            push acc
074A 900382     563            mov dptr, #setup3
074D 120338     563            lcall ?Send_Constant_String
0750 D0E0       563            pop acc
0752 D082       563            pop dpl
0754 D083       563            pop dph
0756 C0E0       564            push acc
0758 7401       564            mov a, #1
075A 14         564            dec a
075B 120343     564            lcall ?Set_Cursor_2 ; Select column and row
075E D0E0       564            pop acc
0760 C083       565            push dph
0762 C082       565            push dpl
0764 C0E0       565            push acc
0766 900371     565            mov dptr, #setup2
0769 120338     565            lcall ?Send_Constant_String
076C D0E0       565            pop acc
076E D082       565            pop dpl
0770 D083       565            pop dph
0772            566   updateReflowScreen:
0772 C0E0       567            push acc
0774 7405       567            mov a, #5
0776 14         567            dec a
0777 120343     567            lcall ?Set_Cursor_2 ; Select column and row
077A D0E0       567            pop acc
077C E54B       568       mov a, reflow_temp
077E 12087A     569       lcall SendToLCD
0781            570       
0781 C0E0       571            push acc
0783 740E       571            mov a, #14
0785 14         571            dec a
0786 120343     571            lcall ?Set_Cursor_2 ; Select column and row
0789 D0E0       571            pop acc
078B E54C       572       mov a, reflow_time
078D 12087A     573       lcall SendToLCD
0790            574       
0790 E547       575       mov a, edit_sett
0792 B4020C     576       cjne a, #2, indic_refl_time
0795 C0E0       577            push acc
0797 7406       577            mov a, #6
0799 14         577            dec a
079A 120345     577            lcall ?Set_Cursor_1 ; Select column and row
079D D0E0       577            pop acc
079F 800A       578       sjmp indic_refl_next
07A1            579   indic_refl_time:
07A1 C0E0       580            push acc
07A3 740F       580            mov a, #15
07A5 14         580            dec a
07A6 120345     580            lcall ?Set_Cursor_1 ; Select column and row
07A9 D0E0       580            pop acc
07AB            581   indic_refl_next:
07AB C0E0       582            push acc
07AD 742A       582            mov a, #'*'
07AF 120304     582            lcall ?WriteData
07B2 D0E0       582            pop acc
07B4 22         583       ret
07B5            584   coolScreen:
07B5 C0E0       585            push acc
07B7 7401       585            mov a, #1
07B9 14         585            dec a
07BA 120345     585            lcall ?Set_Cursor_1 ; Select column and row
07BD D0E0       585            pop acc
07BF C083       586            push dph
07C1 C082       586            push dpl
07C3 C0E0       586            push acc
07C5 900393     586            mov dptr, #setup4
07C8 120338     586            lcall ?Send_Constant_String
07CB D0E0       586            pop acc
07CD D082       586            pop dpl
07CF D083       586            pop dph
07D1 C0E0       587            push acc
07D3 7401       587            mov a, #1
07D5 14         587            dec a
07D6 120343     587            lcall ?Set_Cursor_2 ; Select column and row
07D9 D0E0       587            pop acc
07DB C083       588            push dph
07DD C082       588            push dpl
07DF C0E0       588            push acc
07E1 9003A4     588            mov dptr, #setup5
07E4 120338     588            lcall ?Send_Constant_String
07E7 D0E0       588            pop acc
07E9 D082       588            pop dpl
07EB D083       588            pop dph
07ED            589   updateCoolScreen:
07ED C0E0       590            push acc
07EF 7405       590            mov a, #5
07F1 14         590            dec a
07F2 120343     590            lcall ?Set_Cursor_2 ; Select column and row
07F5 D0E0       590            pop acc
07F7 E54D       591       mov a, cool_temp
07F9 12087A     592       lcall SendToLCD
07FC 22         593       ret
07FD            594   
07FD            595   
07FD            596   pollButtons:
07FD 20861B     597       jb EDIT, DONT_EDIT           
0800 C002       598            push AR2
0802 7A64       598            mov R2, #100
0804 1202BF     598            lcall ?Wait_Milli_Seconds
0807 D002       598            pop AR2                 
0809 20860F     599            jb EDIT, DONT_EDIT
080C 3086FD     600            jnb EDIT, $
080F            601   
080F E547       602       mov a, edit_sett
0811 B40404     603       cjne a, #4, incEdit
0814 754700     604       mov edit_sett, #0
0817            605       ;ljmp setupDisplay
0817 22         606       ret
0818 0547       607       incEdit: inc edit_sett
081A            608       ;ljmp setupDisplay
081A 22         609       ret
081B            610   
081B            611   ; 0 - soak temp
081B            612   ; 1 - soak time
081B            613   ; 2 - reflow temp
081B            614   ; 3 - reflow time
081B            615   ; 4 - cool temp   
081B            616   DONT_EDIT:
081B 20832C     617       jb INCR, DONT_INC    
081E C002       618            push AR2
0820 7A32       618            mov R2, #50
0822 1202BF     618            lcall ?Wait_Milli_Seconds
0825 D002       618            pop AR2                 
0827 208320     619            jb INCR, DONT_INC               
082A 3083FD     620            jnb INCR, $
082D            621       
082D E547       622       mov a, edit_sett
082F B40003     623       cjne a, #0, elem1
0832 0549       624       inc soak_temp
0834            625       ;lcall save_config                                   ; save config to nvmem
0834            626       ;lcall updateSoakScreen
0834 22         627       ret
0835 B40103     628       elem1: cjne a, #1, elem2
0838 054A       629       inc soak_time
083A            630       ;lcall save_config                                   ; save config to nvmem
083A            631       ;lcall updateSoakScreen
083A 22         632       ret
083B B40203     633       elem2: cjne a, #2, elem3
083E 054B       634       inc reflow_temp
0840            635       ;lcall updateReflowScreen
0840            636       ;lcall save_config                                   ; save config to nvmem
0840 22         637       ret
0841 B40303     638       elem3: cjne a, #3, elem4
0844 054C       639       inc reflow_time
0846            640       ;lcall updateReflowScreen
0846            641       ;lcall save_config                                   ; save config to nvmem
0846 22         642       ret
0847 054D       643       elem4: inc cool_temp
0849            644       ;lcall updateCoolScreen
0849            645       ;lcall save_config                                   ; save config to nvmem
0849 22         646       ret
084A            647       
084A            648   DONT_INC:
084A 20802C     649       jb DECR, DONT_DEC
084D C002       650            push AR2
084F 7A32       650            mov R2, #50
0851 1202BF     650            lcall ?Wait_Milli_Seconds
0854 D002       650            pop AR2                 
0856 208020     651            jb DECR, DONT_DEC       
0859 3080FD     652            jnb DECR, $
085C            653   
085C E547       654       mov a, edit_sett
085E B40003     655       cjne a, #0, delem1
0861 1549       656       dec soak_temp
0863            657       ;lcall updateSoakScreen
0863            658       ;lcall save_config                                   ; save config to nvmem
0863 22         659       ret
0864 B40103     660       delem1: cjne a, #1, delem2
0867 154A       661       dec soak_time
0869            662       ;lcall updateSoakScreen
0869            663       ;lcall save_config                                   ; save config to nvmem
0869 22         664       ret
086A B40203     665       delem2: cjne a, #2, delem3
086D 154B       666       dec reflow_temp
086F            667       ;lcall updateReflowScreen
086F            668       ;lcall save_config                                   ; save config to nvmem
086F 22         669       ret
0870 B40303     670       delem3: cjne a, #3, delem4
0873 154C       671       dec reflow_time
0875            672       ;lcall updateReflowScreen
0875            673       ;lcall save_config                                   ; save config to nvmem
0875 22         674       ret
0876 154D       675       delem4: dec cool_temp
0878            676       ;lcall updateCoolScreen
0878            677       ;lcall save_config                                   ; save config to nvmem
0878 22         678       ret
0879            679   
0879            680   DONT_DEC: 
0879 22         681       ret
087A            682   
087A            683   SendToLCD: ;check slides from prof jesus
087A 75F064     684       mov b, #100
087D 84         685       div ab
087E 4430       686       orl a, #0x30 ; Convert hundreds to ASCII
0880 120304     687       lcall ?WriteData ; Send to LCD
0883 E5F0       688       mov a, b ; Remainder is in register b
0885 75F00A     689       mov b, #10
0888 84         690       div ab
0889 4430       691       orl a, #0x30 ; Convert tens to ASCII
088B 120304     692       lcall ?WriteData; Send to LCD
088E E5F0       693       mov a, b
0890 4430       694       orl a, #0x30 ; Convert units to ASCII
0892 120304     695       lcall ?WriteData; Send to LCD
0895 22         696       ret
0896            697   ;-------------------------------------------------------------------------------
0896            698   
0896            699   ;-----------------------------------FSM & PWM----------------------------------------
0896            700   
0896            701   reset:
0896 20A613     702            jb RST, DONT_RESET                              ; if 'RESET' is pressed, wait for rebouce
0899 C002       703            push AR2
089B 7A32       703            mov R2, #50
089D 1202BF     703            lcall ?Wait_Milli_Seconds
08A0 D002       703            pop AR2                         ; Debounce delay.  This macro is also in 'LCD_4bit.inc'
08A2 20A607     704            jb RST, DONT_RESET                              ; if the 'RESET' button is not pressed skip
08A5 30A6FD     705            jnb RST, $
08A8 7405       706            mov a, #5                                               ; reset to state 5 when reset for safety
08AA F548       707            mov state, a
08AC            708   DONT_RESET: 
08AC 22         709       ret  
08AD            710   
08AD            711   start_or_not:
08AD 20C511     712            jb START_STOP, DONT_START               ; if 'RESET' is pressed, wait for rebouce
08B0 C002       713            push AR2
08B2 7A32       713            mov R2, #50
08B4 1202BF     713            lcall ?Wait_Milli_Seconds
08B7 D002       713            pop AR2                         ; Debounce delay.  This macro is also in 'LCD_4bit.inc'
08B9 20C505     714            jb START_STOP, DONT_START               ; if the 'RESET' button is not pressed skip
08BC 30C5FD     715            jnb START_STOP, $
08BF B201       716            cpl start_flag
08C1            717   DONT_START: 
08C1 22         718       ret  
08C2            719   
08C2            720   PWM_OUTPUT:
08C2 E54E       721            mov a, pwm
08C4 B46409     722            cjne a, #100, holding_temp              ; if pwm is 100, then OUTPUT = 1 all 
08C7 D282       723            setb OUTPUT                                             ; the time
08C9 22         724            ret
08CA            725   
08CA B40003     726            cjne a, #0, holding_temp                ; if pwm is 0, then OUTPUT = 0 all
08CD C282       727            clr OUTPUT                                              ; the time
08CF 22         728            ret
08D0            729   
08D0            730            holding_temp:   
08D0 E542       731            mov a, Count1ms
08D2 B4000E     732            cjne a, #0 , Not_yet                    ; check whether it is time to turn on the pwm pin                
08D5 C282       733            clr OUTPUT                                              ; clr OUTPUT if at the begining of the period
08D7 E542       734            mov a, Count1ms+0
08D9 B42007     735            cjne a, #low(PWM_HOLD_RATE), Not_yet    ; Warning: this instruction changes the carry flag!
08DC E543       736            mov a, Count1ms+1
08DE B40302     737            cjne a, #high(PWM_HOLD_RATE), Not_yet   ; if Count1ms = PWM_HOLD_RATE, set the OUTPUT to 1
08E1 D282       738            setb OUTPUT
08E3 22         739   Not_yet: ret
08E4            740   
08E4            741   Load_Defaults: ; Load defaults if 'keys' are incorrect
08E4 754923     742            mov soak_temp, #35                              ; 150
08E7 754A0A     743            mov soak_time, #10                              ; 45
08EA 754B32     744            mov reflow_temp, #50                    ; 225
08ED 754C05     745            mov reflow_time, #5                             ; 30
08F0 754D1E     746       mov cool_temp, #30                           ; 50
08F3 22         747            ret
08F4            748   
08F4            749   ;-------------------------------------FSM time!!---------------------------------------
08F4            750   FSM:                                                      
08F4 E548       751            mov a, state
08F6            752   state0:                                                  ; default state
08F6 B40011     753            cjne a, #0, state1                      ; if not state 0, then go to next branch
08F9 754E00     754            mov pwm, #0                                     ; at state 0, pwm is 0%
08FC 1208AD     755            lcall start_or_not
08FF 300105     756            jnb start_flag, state0_done     ; if start key is not press, the go to state0_done
0902 754801     757            mov state, #1
0905 C201       758            clr start_flag
0907            759   state0_done:
0907 020538     760            ljmp forever
090A            761   state1:                                                  ; ramp to soak
090A B40115     762            cjne a, #1, state2
090D 754E64     763            mov pwm, #100
0910 754F00     764            mov sec, #0
0913 E549       765            mov a, soak_temp
0915 C3         766            clr c
0916 9550       767            subb a, temp                            ; if temp > soak_temp, c = 1
0918 5005       768            jnc state1_done                                 ; if temp is not at soak temp, then go to state1_done
091A 754802     769            mov state, #2
091D D201       770            setb start_flag
091F            771   state1_done:
091F 020538     772            ljmp forever
0922            773   
0922            774   state2:                                                  ; soak/preheat
0922 B40210     775            cjne a, #2, state3
0925 754E14     776            mov pwm, #HOLD_PWM
0928 E54A       777            mov a, soak_time
092A C3         778            clr c
092B 954F       779            subb a, sec                                     ; if sec > soak time, c = 1
092D 5003       780            jnc state2_done                                 ; if sec is not at soak time, then go to state2_done 
092F 754803     781            mov state, #3   
0932            782   state2_done:
0932 020538     783            ljmp forever
0935            784   
0935            785   state3:                                                  ; ramp to peak, prepare to reflow
0935 B40313     786            cjne a, #3, state4
0938 754E64     787            mov pwm, #100
093B 754F00     788            mov sec, #0
093E E54B       789            mov a, reflow_temp
0940 C3         790            clr c
0941 9550       791            subb a, temp                            ; if temp > reflow_temp, c = 1
0943 5003       792            jnc state3_done                                 ; if temp is not at reflow_temp, then go to state3_done 
0945 754804     793            mov state, #4   
0948            794   state3_done:
0948 020538     795            ljmp forever
094B            796   
094B            797   state4:                                                  ; ramp to peak, prepare to reflow
094B B40410     798            cjne a, #4, state5
094E 754E14     799            mov pwm, #HOLD_PWM
0951 E54C       800            mov a, reflow_time
0953 C3         801            clr c
0954 954F       802            subb a, sec                                     ; if sec > reflow_temp, c = 1
0956 5003       803            jnc state4_done                                 ; if sec is not at reflow time, then go to state4_done 
0958 754805     804            mov state, #5   
095B            805   state4_done:
095B 020538     806            ljmp forever
095E            807   
095E            808   state5:                                                  ; cooling state
095E B40595     809            cjne a, #5, state0
0961 754E00     810            mov pwm, #0
0964 E550       811            mov a, temp
0966 C3         812            clr c
0967 954D       813            subb a, cool_temp                       ; if cool_temp > temp, c = 1
0969 5003       814            jnc state5_done                                 ; if temp is not at cool_temp, then go to state5_done 
096B 754800     815            mov state, #0   
096E            816   state5_done:
096E 020538     817            ljmp forever 
0971            818   ;----------------------------------------------------------------------------------------
0971            819   
0971            820   ;---------------------------------save to nvmem-------------------------------
0971            821   save_config:
0971 C0A8       822       push IE ; Save the current state of bit EA in the stack
0973 C2AF       823       clr EA ; Disable interrupts
0975 75D108     824            mov FCON, #0x08 ; Page Buffer Mapping Enabled (FPS = 1)
0978 907F80     825            mov dptr, #0x7f80 ; Last page of flash memory
097B            826            ; Save variables
097B E549       827            mov a, soak_temp
097D F0         827            movx @dptr, a
097E A3         827            inc dptr ; @0x7f80
097F E54A       828            mov a, soak_time
0981 F0         828            movx @dptr, a
0982 A3         828            inc dptr ; @0x7f81
0983 E54B       829            mov a, reflow_temp
0985 F0         829            movx @dptr, a
0986 A3         829            inc dptr ; @0x7f82
0987 E54C       830            mov a, reflow_time
0989 F0         830            movx @dptr, a
098A A3         830            inc dptr ; @0x7f83
098B E54D       831            mov a, cool_temp
098D F0         831            movx @dptr, a
098E A3         831            inc dptr ; @0x7f84
098F 7455       832            mov a, #0x55
0991 F0         832            movx @dptr, a
0992 A3         832            inc dptr ; First key value @0x7f84
0993 74AA       833            mov a, #0xAA
0995 F0         833            movx @dptr, a
0996 A3         833            inc dptr ; Second key value @0x7f85
0997 75D100     834            mov FCON, #0x00 ; Page Buffer Mapping Disabled (FPS = 0)
099A 43D240     835            orl EECON, #0b01000000 ; Enable auto-erase on next write sequence
099D 75D150     836            mov FCON, #0x50 ; Write trigger first byte
09A0 75D1A0     837            mov FCON, #0xA0 ; Write trigger second byte
09A3            838            ; CPU idles until writing of flash completes.
09A3 75D100     839            mov FCON, #0x00 ; Page Buffer Mapping Disabled (FPS = 0)
09A6 53D2BF     840            anl EECON, #0b10111111 ; Disable auto-erase
09A9 D0A8       841            pop IE ; Restore the state of bit EA from the stack
09AB 22         842       ret
09AC            843   ;-----------------------------------------------------------------------------
09AC            844   
09AC            845   ;------------------------------read from nvmem--------------------------------
09AC            846   Load_Configuration:
09AC 907F84     847       mov dptr, #0x7f84 ; First key value location.
09AF E4         848       clr a
09B0 93         848       movc a, @a+dptr
09B1 F8         848       mov R0, a
09B2 A3         848       inc dptr ; 0x7f84 should contain 0x55
09B3 B85524     849       cjne R0, #0x55, jumpToLoadDef
09B6 E4         850       clr a
09B7 93         850       movc a, @a+dptr
09B8 F8         850       mov R0, a
09B9 A3         850       inc dptr ; 0x7f85 should contain 0xAA
09BA B8AA1D     851       cjne R0, #0xAA, jumpToLoadDef
09BD            852   ; Keys are good. Get stored values.
09BD 907F80     853       mov dptr, #0x7f80
09C0 E4         854       clr a
09C1 93         854       movc a, @a+dptr
09C2 F549       854       mov soak_temp, a
09C4 A3         854       inc dptr ; 0x7f80
09C5 E4         855       clr a
09C6 93         855       movc a, @a+dptr
09C7 F54A       855       mov soak_time, a
09C9 A3         855       inc dptr ; 0x7f81
09CA E4         856       clr a
09CB 93         856       movc a, @a+dptr
09CC F54B       856       mov reflow_temp, a
09CE A3         856       inc dptr ; 0x7f82
09CF E4         857       clr a
09D0 93         857       movc a, @a+dptr
09D1 F54C       857       mov reflow_time, a
09D3 A3         857       inc dptr ; 0x7f83
09D4 E4         858       clr a
09D5 93         858       movc a, @a+dptr
09D6 F54D       858       mov cool_temp, a
09D8 A3         858       inc dptr
09D9 22         859       ret
09DA            860   jumpToLoadDef:
09DA 0208E4     861            ljmp Load_Defaults
09DD            862   ;----------------------------------------------------------------------------
09DD            863   
09DD            864   ;----------------------------------------------------------------------
09DD            865   cold_junc:
09DD            866   
09DD 22         867   ret
09DE            868   ;----------------------------------------------------------------------
09DE            869   
09DE            870   
09DE            871   ;----------------------------------------------------------------------
09DE            872   hot_junc:
09DE            873   
09DE 22         874   ret
09DF            875   ;----------------------------------------------------------------------
09DF            876   
09DF            877   END
